import discord
import os
from keep_alive import keep_alive
from discord import app_commands
#å¤©æ°—
import openmeteo_requests
import requests_cache
import pandas as pd
from retry_requests import retry

intents = discord.Intents.default()
intents.message_content = True
client = discord.Client(intents=intents)
tree = app_commands.CommandTree(client)


#å¤©æ°—äºˆå ±
# Setup the Open-Meteo API client with cache and retry on error
cache_session = requests_cache.CachedSession('.cache', expire_after = 3600)
retry_session = retry(cache_session, retries = 5, backoff_factor = 0.2)
openmeteo = openmeteo_requests.Client(session = retry_session)

# Make sure all required weather variables are listed here
# The order of variables in hourly or daily is important to assign them correctly below
url = "https://api.open-meteo.com/v1/forecast"
params = {
	"latitude": 35.6895,
	"longitude": 139.6917,
	"hourly": "precipitation",
	"daily": ["temperature_2m_max", "temperature_2m_min"],
	"timezone": "Asia/Tokyo",
	"forecast_days": 3
}
responses = openmeteo.weather_api(url, params=params)

# Process first location. Add a for-loop for multiple locations or weather models
response = responses[0]
print(f"Coordinates {response.Latitude()}Â°N {response.Longitude()}Â°E")
print(f"Elevation {response.Elevation()} m asl")
print(f"Timezone {response.Timezone()} {response.TimezoneAbbreviation()}")
print(f"Timezone difference to GMT+0 {response.UtcOffsetSeconds()} s")












@client.event
async def on_ready():
    print('ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸ')
 # ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’è¨­å®š
    activity = discord.Activity(name='ç–¾é¢¨ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ã‚¿ãƒ¼', type=discord.ActivityType.competing)
    await client.change_presence(status=discord.Status.online, activity=activity)

    # ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã‚’åŒæœŸ
    await tree.sync()
# @client.event
# async def on_message(message):
 #   emoji ="ğŸ‘"
  #  await message.add_reaction(emoji)
# ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰
@tree.command(name='membercount', description='ã‚µãƒ¼ãƒãƒ¼ã®äººæ•°ã‚’è¡¨ç¤ºã—ã¾ã™') 
async def on_message(message):
    # message ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ guild ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
    guild = message.guild 
    # ãƒ¦ãƒ¼ã‚¶ã¨BOTã‚’åŒºåˆ¥ã—ãªã„å ´åˆ
    member_count = guild.member_count
    await message.response.send_message(f'ä»Šã®äººæ•°ã¯{member_count}ã§ã™')

#@client.event
#async def on_message(call_message):
#    if call_message.author != client.user:
#        if client.user in call_message.mentions: # è©±ã—ã‹ã‘ã‚‰ã‚ŒãŸã‹ã®åˆ¤å®š
#            reply = f'{call_message.author.mention} å‘¼ã³ã¾ã—ãŸã‹ï¼Ÿ' # è¿”ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä½œæˆ
#            await call_message.channel.send(reply) # è¿”ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
        
@client.event
async def on_message(message):
    if message.author.bot:
        return
    if message.content == "ã“ã‚“ã«ã¡ã¯":
        await message.channel.send("ã“ã‚“ã«ã¡ã¯ï¼")
    elif client.user in message.mentions: # è©±ã—ã‹ã‘ã‚‰ã‚ŒãŸã‹ã®åˆ¤å®š
        await message.channel.send(f'{message.author.mention} å‘¼ã³ã¾ã—ãŸã‹ï¼Ÿ') # è¿”ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
    elif message.content == "ã„ã„ã­":
        emoji ="ğŸ‘"
        await message.add_reaction(emoji)
    elif message.content == "å¤©æ°—":
        # Process hourly data. The order of variables needs to be the same as requested.
        hourly = response.Hourly()
        hourly_precipitation = hourly.Variables(0).ValuesAsNumpy()
        
        hourly_data = {"date": pd.date_range(
            start = pd.to_datetime(hourly.Time(), unit = "s", utc = True),
            end = pd.to_datetime(hourly.TimeEnd(), unit = "s", utc = True),
            freq = pd.Timedelta(seconds = hourly.Interval()),
            inclusive = "left"
        )}
        hourly_data["precipitation"] = hourly_precipitation
        hourly_dataframe = pd.DataFrame(data = hourly_data)
        await message.send(hourly_dataframe)


TOKEN = os.getenv("DISCORD_TOKEN")
# Web ã‚µãƒ¼ãƒã®ç«‹ã¡ä¸Šã’
keep_alive()
client.run(TOKEN)
